
//#2869
//failed
//하루에 A만큼 올라갔을 때 정상에 도착했다면 반복문을 종료한다
//정상에 도착하지 못했다면 B만큼 미끄러지고 반복문을 한바퀴 더 돈다
/*
int main() {

	int A, B, V;
	int cnt = 0;
	int inow = 0;

	scanf_s("%d %d %d", &A, &B, &V);

	while (true)
	{
		cnt += 1;
		inow += A;

		if (inow >= V)
			break;

		inow -= B;

	}

	printf("%d", cnt);

	return 0;
}
*/
//문제점 : V가 크고 A와 B의 차이가 작을 경우 연산 횟수가 너무 많아짐
//반복문으로는 어렵다고 판단하여 폐기했다
//최악의 경우와 최선의 경우가 어떤 경우인지 한번씩 생각해 보는 습관이 중요할 듯 하다
//논리적으로 옳고 깔끔하더라도 최적화 할 수 있는 경우가 있음을 유의할 것
//컴퓨터 입장도 한번씩 배려 해주자





//2869
// successed
// 옛날에 어디선가 본 계단 오르는 토끼 문제처럼 풀면 된다
// 예를 들어 A = 2, B = 1, V = 5일 경우
// 도착하기 전날에 3미터 이상의 높이에 올라와있어야 한다
// 즉 V - A = 3 에 도달하고 하루만 더 지나면 도착인데,
// 그 전날까진 2 - 1 = 1 씩 올라가는 것과 마찬가지.
// 따라서 V - A 를 한 후 이를 A - B로 나눈 몫 + 1 울 하면 된다
// 최선의 경우 하루만에 끝날 수 있으니 그 경우는 따로 빼준다
// 거의 최선에 가까운 경우 한번 상승 후 하강, 그 다음번 상승에 정상에 도착하므로 이 경우도 따로 빼준다

#include <iostream>

int main() {


	int A, B, V;
	int togo;

	scanf_s("%d %d %d", &A, &B, &V);

	togo = V - A;

	if (togo <= 0) printf("1");
	
	else {
		
		if (togo % (A - B) != 0) printf("%d",togo / (A - B) + 2);
		else printf("%d", togo / (A - B) + 1);
	}
	

	return 0;

}




