
//#2869
//failed
//하루에 A만큼 올라갔을 때 정상에 도착했다면 반복문을 종료한다
//정상에 도착하지 못했다면 B만큼 미끄러지고 반복문을 한바퀴 더 돈다
/*
int main() {

	int A, B, V;
	int cnt = 0;
	int inow = 0;

	scanf_s("%d %d %d", &A, &B, &V);

	while (true)
	{
		cnt += 1;
		inow += A;

		if (inow >= V)
			break;

		inow -= B;

	}

	printf("%d", cnt);

	return 0;
}
*/
//문제점 : V가 크고 A와 B의 차이가 작을 경우 연산 횟수가 너무 많아짐
//반복문으로는 어렵다고 판단하여 폐기했다
//최악의 경우와 최선의 경우가 어떤 경우인지 한번씩 생각해 보는 습관이 중요할 듯 하다
//논리적으로 옳고 깔끔하더라도 최적화 할 수 있는 경우가 있음을 유의할 것
//컴퓨터 입장도 한번씩 배려 해주자





//2869
// successed
// 옛날에 어디선가 본 계단 오르는 토끼 문제처럼 풀면 된다
// 예를 들어 A = 2, B = 1, V = 5일 경우
// 도착하기 전날에 3미터 이상의 높이에 올라와있어야 한다
// 즉 V - A = 3 이상에 도달하고 하루만 더 지나면 도착인데,
// 그 전날까진 2 - 1 = 1 씩 올라가는 것과 마찬가지.
// 따라서 V - A 를 한 후 이를 A - B로 나눈 몫 + 1 을 하면 된다

// 조심해야 할 점은 나눗셈 (V - A) / (A - B) 이 나누어 떨어지지 않으면 하루가 더 필요하다는 것이다.
// 예를 들어 5 2 10 의 경우
// 10 - 5 = 5, 즉 5의 높이 이상에 도달하면 하루만 더 지나면 정상에 도달하는 것인데,
// 5 / (5-2) 를 해보면 몫이 1이고 나머지가 2이다. (정확히 5에서 정상으로 올라가지 못하고 5보다 높은 높이에서 정상에 도달하기 위해 하루가 더 필요하다는 얘기)
// 다시 말해 3 -> 6 -> 10 으로 정상에 도달하므로 3일이 걸린다.

// 최선의 경우 하루만에 끝날 수 있으니 그 경우는 따로 빼줬다 

#include <iostream>

int main() {


	int A, B, V;
	int togo;

	scanf_s("%d %d %d", &A, &B, &V);

	togo = V - A;

	if (togo <= 0) printf("1");
	
	else {
		
		if (togo % (A - B) != 0) printf("%d",togo / (A - B) + 2);
		else printf("%d", togo / (A - B) + 1);
	}
	

	return 0;

}




